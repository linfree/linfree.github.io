---
title: 一段优雅的高级正则打开[断言]之门
date: 2019-10-10 23:32:52
tags:
  - php
desc: 一段优雅的高级正则打开[断言]之门
keywords: php 正则 正则表达式 高级
categories:
- php

---

## 起因
技术群里的群友又提出这样一个问题：

> 能用一个正则表达式，来判断一个密码是否即包含数字，又包含字母，且长度至少为6位吗？

<!--more-->
## 分析问题

1. 长度要6位。（可能用到`{6,}`限制长度）
2. 必须要有数字。 （可能要`\d`,`[0-9]`)
3. 必须要有字母。 （可能要`[A-Za-z]`）

## 思考

如果这个问题要是用php或者py代码验证都非常简单。几个if就解决了。  （可能

但是要求一个正则解决。难道要用正则的if？正则有if吗？？

一查还真有！

## 正则if then else

### 正向先行断言的形式 

```re
(?(?=regex)then|else) 
```
解释是：  
> 如果满足正则regex匹配成功，则必须匹配then部分，否则匹配else部分。四种断言形式都可以使用。  

举个栗子：  

```re
^(?(?=(\d{6,}))\d*|1)$
```
当满足`\d{6,}`时，即大于六个以上数字的时候匹配`\d*`，即全部是数字。  
不满足`\d{6,}`时，匹配数字`1`.

![正则结果.jpg](https://i.loli.net/2019/12/27/8JbTIFnlez49Q2O.png)

### 正向后行断言的形式

该表达式，如果前面是regex的话，匹配后面的then，否则匹配else
```re
(?(?<=regex)then|else) 
```

![1577416282_1_.jpg](https://i.loli.net/2019/12/27/8JbTIFnlez49Q2O.png)



## 正则断言  

if else似乎还是不能优雅的解决问题。但是抛出一个新概念：断言。

正则断言包括
> * 零宽：只匹配位置，在匹配过程中，不占用字符，所以被称为零宽
> 
> * 先行：正则引擎在扫描字符的时候，从左往右扫描，匹配扫描指针未扫描过的字符，先于指针，故称先行
> 
> * 后行：匹配指针已扫描过的字符，后于指针到达该字符，故称后行，即产生回溯
> 
> * 正向：即匹配括号中的表达式
> 
> * 负向：不匹配括号中的表达式

### 零宽断言

零宽正向先行断言，又称正向向前查找（positive lookhead）  
`(?=pattern)`：某位置后面紧接着的字符序列要匹配 pattern

例：
```js
`sinM.`.match(/sin(?=M\.)/g); // ["sin"]
`M.sin`.match(/sin(?=M\.)/g); // null
```
第一个 sin 会匹配，因为他后面有 pattern

## 一个优雅的解
最后,综合一下思路的几个正则段，正则小王子给出这样的一个答案：
```re
^.*(?=.{6,})(?=.*\d)(?=.*[A-Za-z]).*$
```
真漂亮。



